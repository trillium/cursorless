# Migration Plan: test-case-component → ScopeVisualizer Approach

## Executive Summary

This document analyzes migrating **test-case-component** from its custom token manipulation approach to the **ScopeVisualizer** range-based decoration approach, specifically using the `Code` component pattern.

**Goal**: Replace custom HTML generation with Shiki's built-in decoration API while maintaining all current features (hats, selections, temporal states).

**Status**: ⚠️ **Partial compatibility** - Some features (hats) may require workarounds

---

## Current State Analysis

### test-case-component Architecture

```typescript
// Current flow
Fixture Data
  ↓
generateHtml(state, lang)
  ├─ HTMLGenerator.getTokens() - Shiki tokenization
  ├─ HTMLGenerator.applyMarks() - Insert hat tokens
  ├─ HTMLGenerator.applySelections() - Wrap with selection tokens
  └─ renderToHtml(tokens) - Custom HTML builder
  ↓
HTML String (before/during/after)
  ↓
ShikiComponent displays via dangerouslySetInnerHTML
```

**Key Files**:

- `src/generateHtml.ts` (435 lines) - Token manipulation
- `src/renderToHtml.ts` (197 lines) - Custom HTML builder
- `src/loadFixture.ts` - Orchestrates HTML generation
- `src/components/component-shiki.tsx` - Display component

---

### ScopeVisualizer Architecture

```typescript
// ScopeVisualizer flow
Fixture Data
  ↓
calculateHighlights(fixture, rangeType, isIteration)
  ├─ getRanges() - Extract domain/target ranges
  ├─ getDecorations() - Split by line boundaries
  ├─ getHighlights() - Apply colors and borders
  ├─ flattenHighlights() - Resolve overlaps
  └─ highlightsToDecorations() - Convert to Shiki format
  ↓
DecorationItem[]
  ↓
Code component: codeToHtml(code, { decorations })
  ↓
HTML generated by Shiki
  ↓
Display via dangerouslySetInnerHTML
```

**Key Files**:

- `src/docs/components/calculateHighlights.ts` (118 lines)
- `src/docs/components/flattenHighlights.ts` (133 lines)
- `src/docs/components/highlightsToDecorations.ts` (53 lines)
- `src/docs/components/Code.tsx` (103 lines) - React component with runtime generation

---

## What Would Be Replaced

### Files to Remove/Replace

| Current File                         | Lines | Replacement                                               |
| ------------------------------------ | ----- | --------------------------------------------------------- |
| `src/generateHtml.ts`                | 435   | `calculateHighlights.ts` + `flattenHighlights.ts` pattern |
| `src/renderToHtml.ts`                | 197   | Shiki's built-in `codeToHtml()`                           |
| `src/components/component-shiki.tsx` | 34    | Adopt `Code.tsx` pattern                                  |

**Total lines removed**: ~666 lines
**Total lines added**: ~304 lines (Code.tsx + highlight processing)
**Net reduction**: ~362 lines

---

### Files to Keep/Modify

| File                          | Change Required                                                  |
| ----------------------------- | ---------------------------------------------------------------- |
| `src/loadFixture.ts`          | Moderate - Change from `generateHtml()` to decoration generation |
| `src/test-case-component.tsx` | Minimal - Props remain similar                                   |
| `src/generateHtml.spec.ts`    | Major - Rewrite tests for new approach                           |
| `src/types.ts`                | Minor - Add decoration types                                     |

---

## Feature Compatibility Analysis

### ✅ Directly Compatible Features

#### 1. **Selections** (all types)

**Current**: Token wrapping with className

```typescript
{
  type: "selection",
  className: "selection",
  selection: Token[]
}
```

**ScopeVisualizer**: Range-based decorations

```typescript
{
  start: { line: 0, character: 6 },
  end: { line: 0, character: 9 },
  properties: {
    style: "background-color: #ad00bc5b; border: ..."
  }
}
```

**Migration**: Convert selection ranges directly to decorations

---

#### 2. **Overlapping Decorations**

**Current**: Nested token structures

```typescript
{
  type: "selection",
  className: "thatMark selection", // Composed
  selection: [...]
}
```

**ScopeVisualizer**: Flattened with blended styles

```typescript
// flattenHighlights() splits overlaps
{ range: "0:3-0:4", style: { backgroundColor: blended } }
{ range: "0:4-0:5", style: { backgroundColor: blended } }
```

**Migration**: Use `flattenHighlights()` - handles overlap resolution better

---

#### 3. **Line-Level Selections**

**Current**: Line options with CSS classes

```typescript
lineOptions.push({
  line: i,
  classes: ["selection"],
});
```

**ScopeVisualizer**: Full-line decorations

```typescript
{
  start: { line: 1, character: 0 },
  end: { line: 1, character: lineLength },
  properties: { style: "..." }
}
```

**Migration**: Convert line selections to character ranges spanning entire line

---

### ⚠️ Features Requiring Adaptation

#### 4. **Hat Decorations**

**Current**: Custom hat tokens inserted into token stream

```typescript
{
  type: "hat",
  hatType: "default",
  content: "a"
}
```

**Rendered as**:

```html
<span class="hat default">a</span>
```

**Problem**: Shiki's decoration API doesn't support character-level decorations that modify the content itself (hats sit "on top" of characters visually).

**Solution Options**:

##### Option A: CSS Pseudo-elements (Recommended)

```typescript
// Decoration for hat position
{
  start: { line: 0, character: 5 },
  end: { line: 0, character: 6 },
  properties: {
    class: "hat-default", // CSS class instead of inline style
    "data-hat": "default"
  }
}
```

```css
/* CSS */
.hat-default::before {
  content: "^";
  position: absolute;
  top: -1em;
  color: red;
}
```

**Pros**: Clean, works with Shiki
**Cons**: Requires CSS changes, may need additional styling

---

##### Option B: Unicode Overlay Characters

```typescript
// Preprocess code to add combining characters
const codeWithHats = insertCombiningHats(documentContents, marks);
// Then render normally
```

**Example**: `f̂oo` (f with combining circumflex)

**Pros**: No special decoration needed
**Cons**: May affect selection, copying; brittle

---

##### Option C: Post-process HTML

```typescript
// Generate HTML with Shiki, then inject hats
let html = await codeToHtml(code, { decorations });
html = injectHats(html, hatPositions);
```

**Pros**: Full control, maintains current appearance
**Cons**: Defeats purpose of using Shiki's clean API

---

##### Option D: Keep Custom Rendering for Hats Only

```typescript
// Hybrid approach
if (hasHats) {
  return generateHtmlCustom(state, lang); // Current approach
} else {
  return generateHtmlWithShiki(state, lang); // New approach
}
```

**Pros**: No feature loss, gradual migration
**Cons**: Maintains code duplication

---

#### 5. **Multiple Selection Types**

**Current**: Different CSS classes for each type

```typescript
decorations: "decoration";
selections: "selection";
thatMark: "thatMark";
sourceMark: "sourceMark";
```

**ScopeVisualizer**: Single highlight type with color differentiation

```typescript
colors = {
  domain: { background: "#00e1ff18", ... },
  content: { background: "#ad00bc5b", ... },
  removal: { background: "#ff00002d", ... },
}
```

**Migration Strategy**:

```typescript
// Map selection types to color schemes
function getColorsForSelectionType(type: SelectionType) {
  switch (type) {
    case "decoration":
      return { background: "#00e1ff18", border: "..." };
    case "selection":
      return { background: "#ad00bc5b", border: "..." };
    case "thatMark":
      return { background: "#00725f6c", border: "..." };
    case "sourceMark":
      return { background: "#ff00002d", border: "..." };
  }
}
```

**Trade-off**: Lose CSS class flexibility, but gain consistent color handling

---

### ✅ Easy to Add Features

#### 6. **Temporal States (before/during/after)**

**Current**: Three separate HTML generations

```typescript
const before = await generateHtml(initialState, lang);
const during = decorations
  ? await generateHtml({ ...initialState, decorations }, lang)
  : null;
const after = await generateHtml(finalState, lang);
```

**New Approach**: Three separate decoration sets

```typescript
const beforeDecorations = generateDecorations(initialState);
const duringDecorations = decorations
  ? generateDecorations({ ...initialState, decorations })
  : null;
const afterDecorations = generateDecorations(finalState);

// In component
const beforeHtml = await codeToHtml(initialState.documentContents, {
  decorations: beforeDecorations,
});
// ... repeat for during, after
```

**No compatibility issue** - Same pattern, different implementation

---

## Migration Strategy

### Phase 1: Add New Code (No Breaking Changes)

**Goal**: Introduce ScopeVisualizer utilities alongside current code

**Steps**:

1. **Copy utility files** from ScopeVisualizer:

   ```bash
   cp cursorless-org-docs/src/docs/components/flattenHighlights.ts \
      test-case-component/src/utils/
   cp cursorless-org-docs/src/docs/components/highlightsToDecorations.ts \
      test-case-component/src/utils/
   cp cursorless-org-docs/src/docs/components/highlightColors.ts \
      test-case-component/src/utils/
   ```

2. **Create new decoration generator**:

   ```typescript
   // src/generateDecorations.ts (NEW FILE)
   import { flattenHighlights } from "./utils/flattenHighlights";
   import { highlightsToDecorations } from "./utils/highlightsToDecorations";
   import type { CursorlessFixtureState } from "./types";

   export function generateDecorations(
     state: CursorlessFixtureState,
   ): DecorationItem[] {
     const highlights = convertStateToHighlights(state);
     const flattened = flattenHighlights(highlights);
     return highlightsToDecorations(flattened);
   }
   ```

3. **Create new Code-style component**:

   ```typescript
   // src/components/ShikiComponentV2.tsx (NEW FILE)
   import React, { useEffect, useState } from "react";
   import { codeToHtml } from "shiki";
   import { generateDecorations } from "../generateDecorations";

   export const ShikiComponentV2: React.FC<{ data: any }> = ({ data }) => {
     const [beforeHtml, setBeforeHtml] = useState("");
     const [duringHtml, setDuringHtml] = useState("");
     const [afterHtml, setAfterHtml] = useState("");

     useEffect(() => {
       // Generate before state
       const beforeDec = generateDecorations(data.initialState);
       codeToHtml(data.initialState.documentContents, {
         lang: data.languageId,
         theme: "nord",
         decorations: beforeDec
       }).then(setBeforeHtml);

       // Generate during state (if decorations)
       if (data.decorations) {
         const duringDec = generateDecorations({
           ...data.initialState,
           decorations: data.decorations
         });
         codeToHtml(data.initialState.documentContents, {
           lang: data.languageId,
           theme: "nord",
           decorations: duringDec
         }).then(setDuringHtml);
       }

       // Generate after state
       const afterDec = generateDecorations(data.finalState);
       codeToHtml(data.finalState.documentContents, {
         lang: data.languageId,
         theme: "nord",
         decorations: afterDec
       }).then(setAfterHtml);
     }, [data]);

     return (
       <div className="px-4">
         <div className="p-8">
           <h2 className="dark:text-stone-100">{data.command}</h2>
           {beforeHtml && (
             <div dangerouslySetInnerHTML={{ __html: beforeHtml }} />
           )}
           {duringHtml && (
             <div dangerouslySetInnerHTML={{ __html: duringHtml }} />
           )}
           {afterHtml && (
             <div dangerouslySetInnerHTML={{ __html: afterHtml }} />
           )}
         </div>
       </div>
     );
   };
   ```

4. **Add feature flag** in loadFixture.ts:
   ```typescript
   const USE_NEW_RENDERER = process.env.USE_NEW_RENDERER === "true";
   ```

**Duration**: 2-3 days
**Risk**: Low (no breaking changes)

---

### Phase 2: Implement convertStateToHighlights

**Goal**: Convert CursorlessFixtureState to Highlight[] format

**Key Function**:

```typescript
// src/convertStateToHighlights.ts (NEW FILE)
import type { Highlight, CursorlessFixtureState } from "./types";
import { Range } from "@cursorless/common";

export function convertStateToHighlights(
  state: CursorlessFixtureState,
): Highlight[] {
  const highlights: Highlight[] = [];

  // 1. Convert decorations
  if (state.decorations) {
    for (const decoration of state.decorations) {
      highlights.push({
        range: new Range(decoration.anchor, decoration.active),
        style: getStyleForSelectionType("decoration"),
      });
    }
  }

  // 2. Convert selections
  if (state.selections) {
    for (const selection of state.selections) {
      if (selection.type === "line") {
        // Convert to character range
        highlights.push({
          range: new Range(
            { line: selection.anchor.line, character: 0 },
            { line: selection.active.line, character: Infinity },
          ),
          style: getStyleForSelectionType("selection"),
        });
      } else {
        highlights.push({
          range: new Range(selection.anchor, selection.active),
          style: getStyleForSelectionType("selection"),
        });
      }
    }
  }

  // 3. Convert thatMark
  if (state.thatMark) {
    for (const mark of state.thatMark) {
      highlights.push({
        range: new Range(mark.anchor, mark.active),
        style: getStyleForSelectionType("thatMark"),
      });
    }
  }

  // 4. Convert sourceMark
  if (state.sourceMark) {
    for (const mark of state.sourceMark) {
      highlights.push({
        range: new Range(mark.anchor, mark.active),
        style: getStyleForSelectionType("sourceMark"),
      });
    }
  }

  // 5. Convert marks (HATS) - See Phase 3 for hat handling
  // Deferred - requires special handling

  return highlights;
}

function getStyleForSelectionType(type: SelectionType): Style {
  const colors = getColorsForSelectionType(type);
  return {
    backgroundColor: colors.background,
    borderColorSolid: colors.borderSolid,
    borderColorPorous: colors.borderPorous,
    borderStyle: {
      top: BorderStyle.solid,
      bottom: BorderStyle.solid,
      left: BorderStyle.solid,
      right: BorderStyle.solid,
    },
    borderRadius: {
      topLeft: true,
      topRight: true,
      bottomRight: true,
      bottomLeft: true,
    },
  };
}
```

**Duration**: 3-4 days
**Risk**: Medium (core logic translation)

---

### Phase 3: Solve Hat Decoration Problem

**Goal**: Decide on and implement hat rendering strategy

**Recommended Approach**: **Option A (CSS Pseudo-elements)**

**Implementation**:

1. **Add CSS classes to decorations**:

   ```typescript
   // In convertStateToHighlights.ts
   if (state.marks) {
     for (const [key, mark] of Object.entries(state.marks)) {
       const [hatType, letter] = key.split(".");
       highlights.push({
         range: new Range(mark.start, {
           line: mark.start.line,
           character: mark.start.character + 1,
         }),
         style: {
           // Special flag for hats
           className: `hat-${hatType}`,
           dataAttributes: { hat: letter },
         },
       });
     }
   }
   ```

2. **Modify highlightsToDecorations** to support classes:

   ```typescript
   // src/utils/highlightsToDecorations.ts (MODIFIED)
   export function highlightsToDecorations(
     highlights: Highlight[],
   ): DecorationItem[] {
     return highlights.map((highlight): DecorationItem => {
       const { start, end } = highlight.range;
       const props: any = {};

       if (highlight.style.className) {
         props.class = highlight.style.className;
       } else {
         props.style = getStyleString(highlight.style);
       }

       if (highlight.style.dataAttributes) {
         Object.assign(props, highlight.style.dataAttributes);
       }

       return {
         start,
         end,
         alwaysWrap: true,
         properties: props,
       };
     });
   }
   ```

3. **Add CSS for hats**:

   ```css
   /* src/shiki.css */
   .hat-default {
     position: relative;
   }

   .hat-default::before {
     content: attr(data-hat);
     position: absolute;
     top: -1em;
     left: 50%;
     transform: translateX(-50%);
     font-size: 0.8em;
     font-weight: bold;
     color: var(--hat-color, #ee00ff);
     background: var(--hat-background, rgba(238, 0, 255, 0.2));
     border-radius: 3px;
     padding: 2px 4px;
     z-index: 10;
   }
   ```

**Alternative**: If CSS approach doesn't work, use **Option D (Hybrid)** as fallback.

**Duration**: 2-3 days
**Risk**: High (visual fidelity)

---

### Phase 4: Testing & Validation

**Goal**: Ensure feature parity with current implementation

**Test Plan**:

1. **Visual regression tests**:

   ```typescript
   // Compare screenshots of old vs. new rendering
   describe("ShikiComponentV2", () => {
     it("renders selections identically", () => {
       const oldHtml = generateHtml(state, "typescript");
       const newDecorations = generateDecorations(state);
       const newHtml = codeToHtml(code, { decorations: newDecorations });

       expect(screenshotOf(newHtml)).toMatchScreenshot(screenshotOf(oldHtml));
     });
   });
   ```

2. **Feature parity tests**:
   - All 6 existing generateHtml.spec.ts tests pass
   - Hat decorations render correctly
   - Line selections work
   - Overlapping decorations blend properly
   - thatMark/sourceMark render with correct styles

3. **Performance tests**:

   ```typescript
   it("generates HTML faster than current approach", () => {
     const start = Date.now();
     generateDecorations(largeFixture);
     const newTime = Date.now() - start;

     const start2 = Date.now();
     generateHtml(largeFixture, "typescript");
     const oldTime = Date.now() - start2;

     expect(newTime).toBeLessThan(oldTime);
   });
   ```

**Duration**: 3-5 days
**Risk**: Medium (edge cases)

---

### Phase 5: Gradual Rollout

**Goal**: Switch to new implementation safely

**Steps**:

1. **Default to new implementation**:

   ```typescript
   const USE_NEW_RENDERER = process.env.USE_OLD_RENDERER !== "true";
   ```

2. **Monitor for issues** (1-2 weeks)

3. **Remove old code**:
   ```bash
   git rm src/generateHtml.ts
   git rm src/renderToHtml.ts
   git rm src/components/component-shiki.tsx
   git mv src/components/ShikiComponentV2.tsx src/components/ShikiComponent.tsx
   ```

**Duration**: 2-3 weeks
**Risk**: Low (feature flag protection)

---

## Code Changes Detail

### src/loadFixture.ts Changes

**Before**:

```typescript
import { generateHtml, SelectionAnchor } from "./generateHtml";

export async function loadFixture(data: any) {
  const during = data.decorations
    ? await safeGenerateHtml(
        "decorations",
        { ...data.initialState, decorations: data.decorations },
        data.languageId,
      )
    : null;
  const before = await safeGenerateHtml(
    "initialState",
    data.initialState,
    data.languageId,
  );
  const after = await safeGenerateHtml(
    "finalState",
    data.finalState,
    data.languageId,
  );

  return {
    language: data.languageId,
    command: data.command.spokenForm,
    during,
    before,
    after,
  };
}
```

**After**:

```typescript
import { generateDecorations } from "./generateDecorations";
import { codeToHtml } from "shiki";

export async function loadFixture(data: any) {
  // Generate decorations (cheap)
  const beforeDec = generateDecorations(data.initialState);
  const afterDec = generateDecorations(data.finalState);
  const duringDec = data.decorations
    ? generateDecorations({
        ...data.initialState,
        decorations: data.decorations,
      })
    : null;

  // Return data object (HTML generation deferred to component)
  return {
    language: data.languageId,
    command: data.command.spokenForm,
    initialState: data.initialState,
    finalState: data.finalState,
    beforeDecorations: beforeDec,
    duringDecorations: duringDec,
    afterDecorations: afterDec,
  };
}
```

**Key Change**: Return decoration data instead of HTML strings. This shifts HTML generation to the component layer.

---

### Alternative: Keep HTML Generation in loadFixture

If maintaining the two-phase architecture is important:

```typescript
export async function loadFixture(data: any) {
  const beforeDec = generateDecorations(data.initialState);
  const afterDec = generateDecorations(data.finalState);
  const duringDec = data.decorations
    ? generateDecorations({
        ...data.initialState,
        decorations: data.decorations,
      })
    : null;

  // Generate HTML at data layer (maintains two-phase architecture)
  const before = await codeToHtml(data.initialState.documentContents, {
    lang: data.languageId,
    theme: "nord",
    decorations: beforeDec,
  });

  const after = await codeToHtml(data.finalState.documentContents, {
    lang: data.languageId,
    theme: "nord",
    decorations: afterDec,
  });

  const during = duringDec
    ? await codeToHtml(data.initialState.documentContents, {
        lang: data.languageId,
        theme: "nord",
        decorations: duringDec,
      })
    : null;

  return {
    language: data.languageId,
    command: data.command.spokenForm,
    during,
    before,
    after,
  };
}
```

**Advantage**: ShikiComponent stays simple (just displays HTML)
**Trade-off**: Loses some benefits of ScopeVisualizer's runtime generation

---

## Benefits of Migration

### 1. Code Simplification

- **Remove 666 lines** of complex token manipulation
- **Add 304 lines** of simpler range-based logic
- **Net: -362 lines** (~35% reduction)

### 2. Maintainability

- ✅ Use Shiki's official API (better support, updates)
- ✅ Leverage proven overlap resolution algorithm (`flattenHighlights`)
- ✅ Reduce custom HTML generation code
- ✅ Shared code patterns with ScopeVisualizer (easier to maintain both)

### 3. Features

- ✅ Better overlap handling (color blending)
- ✅ Border style support (solid/porous)
- ✅ Corner radius on decorations
- ✅ More sophisticated decoration styling

### 4. Performance

- ✅ Flatter data structures (less memory)
- ✅ Simpler algorithms (potentially faster)
- ⚠️ Runtime generation (slower if not cached)

### 5. Consistency

- ✅ Same decoration system across both visualization tools
- ✅ Shared color schemes
- ✅ Similar code patterns

---

## Risks & Mitigation

### Risk 1: Hat Rendering Quality

**Risk**: CSS pseudo-elements may not match current hat appearance

**Mitigation**:

- Create visual reference images before migration
- Iterate on CSS until pixel-perfect
- Fallback to Option D (hybrid) if CSS approach fails
- Keep old code in git history for comparison

---

### Risk 2: Performance Regression

**Risk**: Runtime HTML generation may be slower than cached HTML strings

**Mitigation**:

- Benchmark before/after
- If slower, keep two-phase architecture (generate HTML in loadFixture)
- Add memoization in React component
- Pre-generate HTML at build time for static content

---

### Risk 3: Feature Parity

**Risk**: Some edge cases may not work correctly

**Mitigation**:

- Comprehensive test suite before switching
- Feature flag for gradual rollout
- Side-by-side comparison tool
- Keep old implementation for 1-2 releases

---

### Risk 4: Breaking Changes

**Risk**: External consumers may depend on HTML string format

**Mitigation**:

- Maintain same API surface (`loadFixture` returns same shape)
- Version bump to indicate internal changes
- Document migration in CHANGELOG
- Provide compatibility shim if needed

---

## Timeline

| Phase                             | Duration      | Dependencies |
| --------------------------------- | ------------- | ------------ |
| Phase 1: Add New Code             | 2-3 days      | None         |
| Phase 2: convertStateToHighlights | 3-4 days      | Phase 1      |
| Phase 3: Hat Solution             | 2-3 days      | Phase 2      |
| Phase 4: Testing                  | 3-5 days      | Phase 3      |
| Phase 5: Rollout                  | 2-3 weeks     | Phase 4      |
| **Total**                         | **4-5 weeks** | -            |

---

## Decision: Maintain Two-Phase Architecture?

### Option A: Keep Two-Phase (Recommended)

**Approach**: Generate decorations → Generate HTML → Display in React

```typescript
// loadFixture.ts
const decorations = generateDecorations(state);
const html = await codeToHtml(code, { decorations }); // ← Generate at data layer
return { before: html, during: html2, after: html3 };

// ShikiComponent.tsx
<div dangerouslySetInnerHTML={{ __html: data.before }} /> // ← Simple display
```

**Pros**:

- ✅ Maintains architecture benefits (cacheability, portability)
- ✅ ShikiComponent stays simple
- ✅ No breaking changes to API
- ✅ Fast display time

**Cons**:

- ❌ Loses runtime flexibility (can't toggle decorations)
- ❌ Still generates HTML at data layer (partial ScopeVisualizer adoption)

---

### Option B: Full ScopeVisualizer Pattern

**Approach**: Generate decorations → Pass to component → Generate HTML at runtime

```typescript
// loadFixture.ts
const decorations = generateDecorations(state);
return {
  initialState: state,
  decorations: decorations, // ← Return decorations only
};

// ShikiComponent.tsx
useEffect(() => {
  codeToHtml(data.initialState.documentContents, {
    decorations: data.decorations,
  }).then(setHtml); // ← Generate at render time
}, [data]);
```

**Pros**:

- ✅ Full adoption of ScopeVisualizer pattern
- ✅ Runtime flexibility (could add toggles)
- ✅ Async, non-blocking
- ✅ Maximum code sharing

**Cons**:

- ❌ Loses two-phase architecture benefits
- ❌ Breaking change (loadFixture returns different shape)
- ❌ Slower first render
- ❌ Can't pre-generate HTML

---

### Recommendation: **Option A** (Keep Two-Phase)

**Rationale**:

1. Preserves unique architectural advantage of test-case-component
2. Maintains API compatibility
3. Gets most benefits (better decoration handling, code reduction)
4. Minimizes risk
5. Can always switch to Option B later if needed

**Implementation**:

```typescript
// src/generateHtmlWithShiki.ts (NEW FILE)
import { generateDecorations } from "./generateDecorations";
import { codeToHtml } from "shiki";

export async function generateHtmlWithShiki(
  state: CursorlessFixtureState,
  lang: string,
): Promise<string> {
  const decorations = generateDecorations(state);
  return codeToHtml(state.documentContents, {
    lang,
    theme: "nord",
    decorations,
  });
}
```

Then in `loadFixture.ts`:

```typescript
import { generateHtmlWithShiki } from "./generateHtmlWithShiki";

export async function loadFixture(data: any) {
  const before = await generateHtmlWithShiki(
    data.initialState,
    data.languageId,
  );
  const after = await generateHtmlWithShiki(data.finalState, data.languageId);
  const during = data.decorations
    ? await generateHtmlWithShiki(
        { ...data.initialState, decorations: data.decorations },
        data.languageId,
      )
    : null;

  return {
    language: data.languageId,
    command: data.command.spokenForm,
    during,
    before,
    after,
  };
}
```

**ShikiComponent stays unchanged!**

---

## Success Criteria

### Must Have

- ✅ All existing tests pass
- ✅ Visual parity with current rendering
- ✅ No performance regression
- ✅ Hat decorations work correctly
- ✅ All selection types render with correct styles

### Nice to Have

- ✅ Better overlap handling than current
- ✅ Code reduction (target: 30%+)
- ✅ Easier to maintain
- ✅ Shared code with ScopeVisualizer

### Acceptable Trade-offs

- ⚠️ Slight changes to decoration appearance (if improvements)
- ⚠️ Different HTML structure (as long as visual output same)
- ⚠️ Hat rendering via CSS (if matches current quality)

---

## Conclusion

**Migration is feasible** with careful planning and the right strategy.

**Key Success Factors**:

1. ✅ Solve hat rendering problem first (Phase 3)
2. ✅ Maintain two-phase architecture (Option A)
3. ✅ Comprehensive testing (Phase 4)
4. ✅ Gradual rollout with feature flag (Phase 5)
5. ✅ Keep old implementation as fallback

**Biggest Challenge**: Hat decorations (CSS pseudo-elements solution recommended)

**Biggest Benefit**: Code simplification (~35% reduction) + better maintainability

**Recommended Approach**: Start with Phase 1 (parallel implementation), validate hat solution early, then proceed based on results.
